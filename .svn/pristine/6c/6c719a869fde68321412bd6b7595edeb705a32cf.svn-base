QUnit.module( 'Bridge.Hand' );
QUnit.test( 'Good Constructor', function( assert ) {
	var direction = 'n';
	var hand = new Bridge.Hand( direction );
	// All default values
	assert.deepEqual( hand.direction, direction, 'Direction matches passed argument' );
	assert.deepEqual( hand.name, Bridge.directions[ direction ].name, 'Name match name of passed direction' );
	 var cards = {};
	 for( var suit in Bridge.suits ) {
	 	cards[ suit ] = {};
	 }		
	 assert.deepEqual( hand.cards, cards, 'Hand has suits but no cards in any suit initially' );
	 assert.deepEqual( hand.numCards, 0, 'No cards initially' );
});	

QUnit.test( 'Bad Constructor', function( assert ) {
	var direction = 'n';
	assert.throws(
		function() {
			var hand = new Bridge.Hand( );
		},
		'Bridge.Hand constructor needs direction argument'
	);
	var direction = 'n';
	assert.throws(
		function() {
			var hand = new Bridge.Hand( 'a' );
		},
		'Bridge.Hand constructor needs valid direction argument'
	);	
});

QUnit.test( 'Set and Get', function( assert ) {
	var direction = 'n';
	var hand = new Bridge.Hand( direction );
	var name = 'Sriram';
	assert.throws(
		function() {
			hand.set();
		},
		'Bridge.Hand.set needs property argument'
	);
	assert.throws(
		function() {
			hand.set( 'random_property' );
		},
		'Bridge.Hand.set needs a known property argument'
	);	
	assert.throws(
		function() {
			hand.set( 'name' );
		},
		'Bridge.Hand.set needs a value argument'
	);			
	hand.set( 'name', name );
	assert.deepEqual( hand.name, name, 'Name match passed name' );
	assert.throws(
		function() {
			hand.get();
		},
		'Bridge.Hand.get needs property argument'
	);	
	assert.throws(
		function() {
			hand.get( 'random_property' );
		},
		'Bridge.Hand.get needs a known property argument'
	);	
	assert.deepEqual( hand.get( 'name' ), name, 'Name matches passed name' );	
	assert.deepEqual( hand.get( 'name' ), hand.name, 'Get retrieves the correct name' );	
	assert.deepEqual( hand.get( 'count' ), 0, 'Num cards should be 0' );
	assert.deepEqual( hand.get( 'count' ), hand.numCards, 'Get retrieves num cards' );	
});

QUnit.test( 'Add and Remove Cards', function( assert ) {
	var direction = 'n';
	var hand = new Bridge.Hand( direction );
	var suit = 's';
	var rank = 'a';
	// Hand should not have any cards
	assert.ok( !hand._hasCard( suit, rank), 'Hand should not have SA' );
	assert.deepEqual( hand.get( 'count' ), 0, 'Hand has 0 cards initially' );
	
	// Add invalid cards
	assert.throws(
		function() {
			hand.addCard();
		},
		'Bridge.Hand.addCard needs suit'
	);	
	assert.throws(
		function() {
			hand.addCard( suit );
		},
		'Bridge.Hand.addCard needs rank'
	);
	
	// Add a card	
	assert.ok( hand.addCard( suit, rank ), 'SA added' );
	assert.ok( hand._hasCard( suit, rank), 'Hand should have SA' );
	assert.deepEqual( hand.get( 'count' ), 1, 'Hand now has 1 card' );	
	
	// Try to add same card
	assert.ok( !hand.addCard( suit, rank ), 'SA already added' );
	assert.ok( hand._hasCard( suit, rank), 'Hand should have SA' );
	assert.deepEqual( hand.get( 'count' ), 1, 'Hand now has 1 card' );
	
	// Add another card		
	suit = 'c';
	rank = '2';
	assert.ok( hand.addCard( suit, rank ), 'C2 added' );
	assert.ok( hand._hasCard( suit, rank), 'Hand should have C2' );
	assert.deepEqual( hand.get( 'count' ), 2, 'Hand now has 2 cards' );	
	
	// remove a card
	assert.ok( hand.removeCard( suit, rank ), 'C2 removed' );
	assert.ok( !hand._hasCard( suit, rank), 'Hand should not have C2' );
	assert.deepEqual( hand.get( 'count' ), 1, 'Hand now has 1 card' );	
	
	// remove same card	
	assert.ok( !hand.removeCard( suit, rank ), 'C2 removed' );
	assert.ok( !hand._hasCard( suit, rank), 'Hand should not have C2' );
	assert.deepEqual( hand.get( 'count' ), 1, 'Hand now has 1 card' );
	
	// remove other card
	suit = 's';
	rank = 'a';
	assert.ok( hand._hasCard( suit, rank), 'Hand should have SA' );
	assert.ok( hand.removeCard( suit, rank ), 'SA removed' );
	assert.ok( !hand._hasCard( suit, rank), 'Hand should not have SA' );
	assert.deepEqual( hand.get( 'count' ), 0, 'Hand now has 0 cards' );	
	
	// Add 13 cards
	suit = 's';
	for( var rank in Bridge.ranks ) {
		hand.addCard( suit, rank );
	}	
	assert.deepEqual( hand.get( 'count' ), 13, 'Hand now has 13 cards' );
	// add one more	
	suit = 'c';
	rank = '2';	
	assert.throws(
		function() {
			hand.addCard( suit, rank );
		},
		'Adding more than 13 cards'
	);
});

QUnit.module( 'Deal Add Cards' );
QUnit.test( 'Good Cards', function( assert ) {
	var deal = new Bridge.Deal();	
	deal.addCard( 's', 'a', 'n' );
	assert.ok( deal._hasCard( 's', 'a', 'n' ), 'Should have added card');
	assert.ok( !deal._hasCard( 's', 'a', 'e' ), 'Should not have card');
	
});
QUnit.test( 'Bad Cards', function( assert ) {
	var deal = new Bridge.Deal();	
	deal.addCard( 's', 'a', 'n' );
	assert.throws(
		function() {
			deal.addCard( 's', 'a', 'e' );
		},
		'Card already added'
	);
	assert.ok( deal._hasCard( 's', 'a', 'n' ), 'Should have added card');
	assert.ok( !deal._hasCard( 's', 'a', 'e' ), 'Should not have card');
	
});

QUnit.module( 'Suit Tests' );
QUnit.test( 'Good Suits', function( assert ) {
	assert.expect(0);
	Bridge.checkSuit( 's' );
	Bridge.checkSuit( 'h' );
	Bridge.checkSuit( 'd' );
	Bridge.checkSuit( 'c' );
});
QUnit.test( 'Bad Suits', function( assert ) {
	assert.throws(
		function() {
			Bridge.checkSuit();
		},
		'No suit specified should throw exception'
	);
	
	assert.throws(
		function() {
			Bridge.checkSuit(null);
		},
		'Null suit specified should throw exception'
	);	

	var suit;
	assert.throws(
		function() {
			Bridge.checkSuit( suit );
		},
		'undefined suit specified should throw exception'
	);	

	assert.throws(
		function() {
			Bridge.checkSuit( 'n' );
		},
		'Bad suit specified should throw exception'
	);	
});
