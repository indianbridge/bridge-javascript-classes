/**
 * Bridge Namespace
 * @namespace
 * @property {object} directions - The compass directions
 * @property {array} directionOrder - directions in order they should be presented
 * @property {object} suits - The suits of cards
 * @property {array} suitOrder - The suits in order of priority
 * @property {object} ranks - The ranks of cards
 * @property {array} rankOrder - The ranks in order of priority
 * @property {object} vulnerabilities - The list of possible vulnerabilities
 */
var Bridge = {
	directions : { 
		'n' : { name : 'North', lho: 'e', rho: 'w', cho: 's', index: 0, html: 'North' },
		'e' : { name : 'East',  lho: 's', rho: 'n', cho: 'w', index: 1, html: 'East' },
		's' : { name : 'South', lho: 'w', rho: 'e', cho: 'n', index: 2, html: 'South' },
		'w' : { name : 'West',  lho: 'n', rho: 's', cho: 'e', index: 3, html: 'West' }
	},
	directionOrder: [],

	suits : {
		's' : { name : 'Spades', index : 0, html : '<font color="000000">&spades;</font>' }, 
		'h' : { name : 'Hearts', index : 1, html : '<font color="CB0000">&hearts;</font>' }, 
		'd' : { name : 'Diamonds', index : 2, html : '<font color="CB0000">&diams;</font>' }, 
		'c' : { name : 'Clubs', index : 3, html : '<font color="000000">&clubs;</font>' }
	},
	suitOrder: [],

	ranks : { 
		'a' : { name : 'Ace',	index : 0, html: 'A' }, 
		'k' : { name : 'King',	index : 1, html: 'K' }, 
		'q' : { name : 'Queen',	index : 2, html: 'Q' }, 
		'j' : { name : 'Jack',	index : 3, html: 'J' }, 
		't' : { name : 'Ten',	index : 4, html: 'T' }, 
		'9' : { name : 'Nine',	index : 5, html: '9' }, 
		'8' : { name : 'Eight',	index : 6, html: '8' }, 
		'7' : { name : 'Seven',	index : 7, html: '7' }, 
		'6' : { name : 'Six',	index : 8, html: '6' }, 
		'5' : { name : 'Five',	index : 9, html: '5' }, 
		'4' : { name : 'Four',	index : 10, html: '4' }, 
		'3' : { name : 'Three',	index : 11, html: '3' }, 
		'2' : { name : 'Two',	index : 12, html: '2' }
	},
	rankOrder: [],
	
	vulnerabilities : {
		'-' : { name: 'None', index: 0, html: 'None' },
		'n' : { name: 'NS', index: 0, html: 'North-South' },
		'e' : { name: 'EW', index: 0, html: 'East-West' },
		'b' : { name: 'Both', index: 0, html: 'None' }
	}
};

/**
 * Adds a key field to enumeration (stored as an object)
 * @param {string} list - The enumeration
 * @private
 */
Bridge.addKey = function( list ) {
	for( var item in list ) {
		list[ item ].key = item;
	}	
};
Bridge.addKey( Bridge.directions );
Bridge.addKey( Bridge.suits );
Bridge.addKey( Bridge.ranks );
Bridge.addKey( Bridge.vulnerabilities );

/**
 * Use the index field to create an array (from keys) in order of index
 * @param {string} list - The list to convert into array
 * @private
 */
Bridge.createIndexArray = function( list ) {
	var returnArray = [];
	for( var item in list ) {
		returnArray[ list[ item ].index ] = item;
	}
	return returnArray;
};
Bridge.directionOrder = Bridge.createIndexArray( Bridge.directions );
Bridge.suitOrder = Bridge.createIndexArray( Bridge.suits );
Bridge.rankOrder = Bridge.createIndexArray( Bridge.ranks );

/**
 * Check to see if a symbol belongs to a list and throw an exception if not.
 * @param {string} element - The element whose membership is being checked
 * @param {string} list - The list whose membership is checked
 * @param {string} listName - The string name of the list whose membership is checked
 * @param {string} [context] - The context ( for example the method ) of this call
 * @private
 * @throws element does not belong to the list
 */
Bridge.checkListMembership = function( element, list, listName, context ) {
	if ( !_.has( list, element ) ) {
		var message = element + ' is not a valid ' + listName;
		Bridge._reportError( message, context );
	}	
};

/**
 * Check to see if direction is a valid direction
 * @param {string} direction - The direction to check
 * @param {string} [context] - The context ( for example the method ) of this call
 * @throws direction is not a valid direction
 */
Bridge.checkDirection = function( direction, context ) {
	Bridge.checkListMembership( direction, Bridge.directions, 'Direction' );
};

/**
 * Check to see if suit is a valid suit
 * @param {string} suit - The suit to check
 * @param {string} [context] - The context ( for example the method ) of this call
 * @throws suit is not a valid suit
 */
Bridge.checkSuit = function( suit, context ) {
	Bridge.checkListMembership( suit, Bridge.suits, 'Suit' );
};

/**
 * Check to see if rank is a valid rank
 * @param {string} rank - The rank to check
 * @param {string} [context] - The context ( for example the method ) of this call
 * @throws rank is not a valid rank
 */
Bridge.checkRank = function( rank, context ) {
	Bridge.checkListMembership( rank, Bridge.ranks, 'Rank' );
};

/**
 * Check to see if vulnerability is a valid vulnerability
 * @param {string} vulnerability - The vulnerability to check
 * @param {string} [context] - The context ( for example the method ) of this call
 * @throws vulnerability is not a valid vulnerability
 */
Bridge.checkVulnerability = function( vulnerability, context ) {
	Bridge.checkListMembership( vulnerability, Bridge.vulnerabilities, 'Vulnerability' );
};

/**
 * Check to see if a required argument is provided
 * @param {*} value - The reuired argument
 * @param {string} name - The name of the argument for printing
 * @param {string} [context] - The context ( for example the method ) of this call 
 * @throws {Error} required value is not specified
 */
Bridge.checkRequiredArgument = function( value, name, context ) {
	if ( !value ) {
		Bridge._reportError( 'Required argument ' + name + ' has not been specified', context );
	}
};

/**
 * What to do when an error is seen?
 * Default if to throw an exception.
 * @param {string} message - The error message
 * @param {string} [context] - The context ( for example the method ) of the Error
 * @throws Error with message context + message
 * @private
 */
Bridge._reportError = function( message, context ) {
	throw new Error( ( context ? context : '' ) + message );
}

/**
 * Creates a new Bridge Deal.
 * @constructor
 * @memberof Bridge
 */
Bridge.Deal = function() {
	/**
	 * Information about the 52 cards.
	 * @member {object}
	 */
	this.cardAssignedTo = {};
	for( var suit in Bridge.suits ) {
		this.cardAssignedTo[ suit ] = {};
		for ( var rank in Bridge.ranks ) {
			this.cardAssignedTo[ suit ][ rank ] = null;
		}
	}	
	
	/**
	 * The 4 hands in this deal
	 * @member {object}
	 */	
	this.hands = {};
	for( var direction in Bridge.directions ) {
		this.hands[ direction ] = new Bridge.Hand( direction );
	}
	
	/**
	 * The board number of this deal.
	 * @member {number}
	 */
	this.board = null;
	
	/**
	 * The vulnerability of this deal.
	 * @member {string}
	 */
	this.vulnerability = null;
	
	/**
	 * The dealer of this deal.
	 * @member {string}
	 */
	this.dealer = null;
	
	/**
	 * Any notes associated with this deal.
	 * @member {string}
	 */
	this.notes = null;	
};


/**
 * Set a property in this deal.
 * The properties that can be set are as follows<br/>
 * board - number - board number<br/>
 * vulnerability - character [ - n e b ] - the vulnerability<br/>
 * dealer - character [ n e s w ] - the dealer <br/>
 * notes - string - Any notes for this deal <br/>
 * @param {string} property - the property to set<br/>
 * @param {string} value - the value to set the property to
 * @param {string} [direction] - some properties apply to certain direction only
 * @return {boolean} true if property was set, false otherwise
 * @throws unknown property
 */
Bridge.Deal.prototype.set = function( property, value, direction ) {
	var prefix = 'In Bridge.Deal.prototype.set - ';
	Bridge.checkRequiredArgument( property, 'Property', prefix );
	Bridge.checkRequiredArgument( value, 'Value for Property ' + property, prefix );
	switch ( property ) {
		case 'board' :
			var boardNum = parseInt( value );
			if ( isNaN( boardNum ) || String( boardNum ) !== String( value ) || boardNum < 1 ) {
				Bridge._reportError( value + ' is not a valid board number', prefix );
			}
			this.board = boardNum;
			break;
		case 'vulnerability' :
			Bridge.checkVulnerability( value );
			this.vulnerability = value;
			break;
		case 'dealer' :
			Bridge.checkDirection( value );
			this.dealer = value;
			break;
		case 'notes' :
			this.notes = notes;
			break;
		case 'name' :
		case 'count' :
			Bridge.checkDirection( direction, prefix );
			this.hands[ direction ].set( property, value );
			break;
		case 'hand' :
			Bridge.checkDirection( direction, prefix );
			this._parseHand( value, direction );
			break;			
		default :
			Bridge._reportError( 'Unknown deal property ' + property, prefix );
	}
};

/**
 * Parse a hand given as BBO handviewer string format.
 * @param {string} handString - the hand in string format
 * @param {string} direction - the direction to assign this hand
 * @return {boolean} true if handstring is correct and all cards are assigned, false otherwise
 * @throws invalid character in hand String
 * @private
 */
 Bridge.Deal.prototype._parseHand = function( handString, direction ) {
 	var seenSuits = {};
 	for( var d in Bridge.directions ) {
		seenSuits[ d ] = false;
	}
 	handString = handString.toLowerCase();
	var currentSuit = '';
	var currentRank = '';
	var directionName = Bridge.directions[ direction ].html;
	for( var i = 0; i < handString.length; ++i ) {
		var prefix = 'In hand for ' + directionName + ' at position ' + (i+1) + ' - ';
		// Read the next character specified in hand
		var currentChar = handString.charAt( i );
		switch( currentChar ) {
			// Check if it specifies suit
			case 'c' :				
			case 'd' :
			case 'h' :
			case 's' :	
				currentSuit = currentChar;
				if ( seenSuits[ currentSuit ] ) {
					Bridge._reportError( ' suit ' + currentSuit + ' has already been seen before!', prefix );
				}
				seenSuits[ currentSuit ] = true;
				break;	
			
			// Special handing for numeric 10
			case '1' :
				if ( currentSuit === '' ) {
					Bridge._reportError( currentChar + ' was found when a suit was expected!', prefix );
				}			
				if ( i < handString.length - 1 && handString.charAt( i+1 ) === '0') {
					currentRank = 't';
					i++;
				}
				else {
					Bridge._reportError( 'a 1 is present without a subsequent 0. Use 10 or t to reprensent the ten.', prefix );
					continue;
				}
				break;
			// All other characters
			default :
				if ( currentSuit === '' ) {
					Bridge._reportError( currentChar + ' was found when a suit was expected!', prefix );
					continue;
				}
				currentRank = currentChar;
				Bridge.checkRank( currentRank, prefix );
				this.addCard( currentSuit, currentRank, direction );
				break;											
		}	
	}	
 };

/**
 * Get value of a property .
 * See {@link Bridge.Deal#set} for list of properties
 * @param {string} property - the property to get
 * @param {string} [direction] - some properties apply to certain direction only
 * @return {*} the value of requested property
 * @throws unknown property
 */
Bridge.Deal.prototype.get = function( property, direction ) {
	var prefix = 'In Bridge.Deal.prototype.get - '
	Bridge.checkRequiredArgument( property, 'Property', prefix );
	switch ( property ) {
		case 'board' :
			return this.board;
			break;
		case 'vulnerability' :
			return this.vulnerability;
			break;
		case 'dealer' :
			return this.dealer;
			break;
		case 'notes' :
			return this.notes;
			break;
		case 'name' :
		case 'count' :
			Bridge.checkDirection( direction, prefix );
			return this.hands[ direction ].get( property );
			break;
		default :
			Bridge._reportError( 'Unknown deal property ' + property, prefix );
	}
};

/**
 * Get value of a property in html form.
 * See {@link Bridge.Deal#set} for list of properties
 * @param {string} property - the property to get
 * @param {string} [direction] - some properties apply to certain direction only
 * @return {*} the value of requested property
 * @throws unknown property
 */
Bridge.Deal.prototype.getHTML = function( property, direction ) {
	var prefix = 'In Bridge.Deal.prototype.getHTML - '
	Bridge.checkRequiredArgument( property, 'Property', prefix );	
	switch ( property ) {
		case 'board' :
			return this.board ? this.board : 'Not Specified';
			break;
		case 'vulnerability' :
			return this.vulnerability ? Bridge.vulnerabilities[ this.vulnerability ].html : 'Not Specified';
			break;
		case 'dealer' :
			return this.dealer ? Bridge.directions[ this.dealer ].html : 'Not Specified';
			break;
		case 'notes' :
			return this.notes ? this.notes : 'Not Specified';
		case 'name' :
		case 'count' :
			Bridge.checkDirection( direction, prefix );
			return this.hands[ direction ].get( property );			
			break;
		default :
			Bridge._reportError( 'Unknown deal property ' + property, prefix );
	}
};
 

/**
 * Add a card to a specific hand or first possible hand.
 * @param {string} suit - The suit of this card
 * @param {string} rank - The rank of this card
 * @param {string} direction - The direction to assign this card to. If not specified add to first hand without 13 cards
 * @return {boolean} Was the card added? Returns false if the card was already in some hand or in case of any errors.
 * @throws suit is not a valid suit
 * @throws rank is not a valid rank 
 * @throws cannot find direction to add card to
 */
Bridge.Deal.prototype.addCard = function( suit, rank, direction ) {
	var prefix = 'In Bridge.Deal.prototype.addCard - '
	// Validate inputs
	Bridge.checkSuit( suit, prefix );
	Bridge.checkRank( rank, prefix );
	
	if ( this.cardAssignedTo[ suit ][ rank ] ) {
		Bridge._reportError( 'Card ' + suit + rank + ' is already assigned to ' + direction, prefix );
	}

	if ( _.isUndefined( direction ) ) {
		// No direction specified so assign to first hand with less than 13 cards
		// @todo how to do this with underscore
		for( var d in Bridge.directions ) {
			if ( this.hands[ d ].numCards < 13 ) {
				direction = d;
				break;
			}
		}
		// Should not get here
		if ( _.isUndefined( direction ) ) {
			Bridge._reportError( 'All hands have 13 cards and so cannot find direction to assign ' + suit + rank + ' to!', prefix );
		}
	}
	else {
		// direction is specified. Check if it is valid.
		Bridge.checkDirection( direction, prefix );
	}
	
	
	
	this.cardAssignedTo[ suit ][ rank ] = direction;
	return this.hands[ direction ].addCard( suit, rank );
};


/**
 * Remove a card from a specific hand or from the hand that holds it.
 * @param {string} suit - The suit of this card
 * @param {string} rank - The rank of this card
 * @param {string} direction - The direction to remove this card from. If not specified remove it from hand that has it
 * @return {boolean} Was the card removed? Returns false if the card was not in any hand or does not belong to hand that was specified.
 */
Bridge.Deal.prototype.removeCard = function( suit, rank, direction ) {
	var prefix = 'In Bridge.Deal.prototype.removeCard - '
	Bridge.checkSuit( suit, prefix );
	Bridge.checkRank( rank, prefix );
	if ( _.isUndefined( direction ) ) {
		direction = this.cardAssignedTo[ suit ][ rank ];
	}
	if ( !direction || !( direction === this.cardAssignedTo[ suit ][ rank] ) ) {
		Bridge._reportError( 'Card ' + suit + rank + ' does not belong to ' + direction, prefix );
	}
	return this.hands[ direction ].removeCard( suit, rank );
};

/**
 * Check if a hand has a card.
 * @param {string} suit - The suit of this card
 * @param {string} rank - The rank of this card
 * @param {string} direction - The direction to check for this card
 * @return {boolean} Does the specified hand have the specified card?
 * @private
 */
Bridge.Deal.prototype._hasCard = function( suit, rank, direction ) {
	var prefix = 'In Bridge.Deal.prototype._hasCard - '
	Bridge.checkSuit( suit, prefix );
	Bridge.checkRank( rank, prefix );
	Bridge.checkDirection( direction, prefix );
	
	return this.cardAssignedTo[ suit ][ rank ] === direction && this.hands[ direction ]._hasCard( suit, rank );
};

/**
 * Assign the rest of the unassigned cards.
 * @return {number} the number of cards assigned.
 */
Bridge.Deal.prototype.assignRest = function() {
	/** Get the unassigned cards and shuffle them. */
	var unassigned = [];
	for( var suit in Bridge.suits ) {
		for ( var rank in Bridge.ranks ) {
			if ( !this.cardAssignedTo[ suit ][ rank ] ) {
				unassigned.push( suit + rank );
			}
		}
	}		
	unassigned = _.shuffle( unassigned );
	
	var assignedCardCount = 0;
	_.each( unassigned, function( card ) {
		if ( this.addCard( card.charAt(0), card.charAt(1) ) ) assignedCardCount++;
	}, this);
	return assignedCardCount;
};

/**
 * Generate a html display of this deal.
 * @return {string} HTML representation of this deal.
 */
Bridge.Deal.prototype.toHTML = function() {
	var html = '';
	html += '<h3>Deal Information</h3>';
	html += 'Board : ' + this.getHTML( 'board' ) + '<br/>';
	html += 'Dealer : ' + this.getHTML( 'dealer') + '<br/>';
	html += 'Vulnerability : ' + this.getHTML( 'vulnerability' ) + '<br/>';
	html += 'Notes : ' + this.getHTML( 'notes' ) + '<br/>';
	html += '<h3>Hands</h3>';
	for(var direction in Bridge.directions) {
		html += this.hands[ direction ].toHTML() + '<br/>';
	};
	/*outputString += '<h3>Auctions</h3>';
	for( var auctionName in this.auctions ) {
		outputString += '<h4>' + auctionName + '</h4>';
		outputString += this.auctions[ auctionName ].toString();	
	};
	outputString += '<h3>Plays</h3>';
	for( var playName in this.plays ) {
		outputString += '<h4>' + playName + '</h4>';
		outputString += this.plays[ playName ].toString();	
	};	*/
	return html;	
};

/**
 * Generate a string display of this deal.
 * @return {string} string representation of this deal.
 */
Bridge.Deal.prototype.toString = function() {
	return this.toHTML();
};

/**
 * Creates a new Bridge Hand.
 * @constructor
 * @memberof Bridge
 * @param {string} direction - The direction this hand is sitting
 */
Bridge.Hand = function( direction ) {
	Bridge.checkDirection( direction );
	/**
	 * The direction of this hand
	 * @member {string}
	 */
	 this.direction = direction;
	 
	/**
	 * The name of person holding this hand
	 * @member {string}
	 */	 
	 this.name = Bridge.directions[ direction ].name;
	 
	/**
	 * The actual cards in this hand
	 * @member {object}
	 */
	 this.cards = {};
	 for( var suit in Bridge.suits ) {
	 	this.cards[ suit ] = {};
	 }
	 
	/**
	 * The number of cards this hand has
	 * @member {number}
	 */	 	 
	 this.numCards = 0;
};

/**
 * Set a property in this hand.
 * The properties that can be set are as follows<br/>
 * name - string - name of player holding this hand<br/>
 * @param {string} property - the property to set<br/>
 * @param {string} value - the value to set the property to
 * @return {boolean} true if property was set, false otherwise
 * @throws unknown property
 */
Bridge.Hand.prototype.set = function( property, value ) {
	var prefix = 'In Bridge.Hand.prototype.set - ';
	Bridge.checkRequiredArgument( property, 'Property', prefix );
	Bridge.checkRequiredArgument( value, 'Value for Property ' + property, prefix );	
	switch ( property ) {
		case 'name' :
			this.name = value;
			break;
		default :
			Bridge._reportError( 'Unknown property ' + property, prefix );
	}
};

/**
 * Get value of a property .
 * See {@link Bridge.Hand#set} for list of properties
 * @param {string} property - the property to get
 * @return {*} the value of requested property
 * @throws unknown property
 */
Bridge.Hand.prototype.get = function( property ) {
	var prefix = 'In Bridge.Hand.prototype.get - ';
	Bridge.checkRequiredArgument( property, 'Property', prefix );
	switch ( property ) {
		case 'name' :
			return this.name;
			break;
		case 'count' :
			return this.numCards;
			break;
		default :
			Bridge._reportError( 'Unknown property ' + property, prefix );
	}
};

/**
 * Add a card to this hand.
 * This is meant to be used by Bridge.Deal.addCard and so does not perform any sanity checks on the inputs.
 * @param {string} suit - The suit of this card
 * @param {string} rank - The rank of this card
 * @return {boolean} Was the card added? Returns false if the card was already int this hand or in case of any errors.
 */
Bridge.Hand.prototype.addCard = function( suit, rank ) {
	var prefix = 'In Bridge.Hand.prototype.addCard - ';
	Bridge.checkSuit( suit, prefix );
	Bridge.checkRank( rank, prefix );
	if ( this.numCards === 13 ) {
		Bridge.reportError( 'Hand with direction : ' + this.direction + ' already has 13 cards. Cannot add ' + suit + rank, prefix );
	}
	if ( !this.cards[ suit ][ rank ] ) {
		this.cards[ suit ][ rank ] = true;
		this.numCards++;
		return true;
	}
	return false;
};

/**
 * Remove a card from this hand.
 * This is meant to be used by Bridge.Deal.removeCard and so does not perform any sanity checks on the inputs.
 * @param {string} suit - The suit of this card
 * @param {string} rank - The rank of this card
 * @return {boolean} Was the card removed? Returns false if the card did not belong to this hand or in case of any errors.
 */
Bridge.Hand.prototype.removeCard = function( suit, rank ) {
	var prefix = 'In Bridge.Hand.prototype.removeCard - ';
	Bridge.checkSuit( suit, prefix );
	Bridge.checkRank( rank, prefix );	
	if ( this.cards[ suit ][ rank ] ) {
		this.cards[ suit ][ rank ] = false;
		this.numCards--;
		return true;
	}
	return false;
};

/**
 * Check if this hand has a card.
 * @param {string} suit - The suit of this card
 * @param {string} rank - The rank of this card
 * @return {boolean} Does this hand have the specified card?
 * @private
 */
Bridge.Hand.prototype._hasCard = function( suit, rank ) {
	var prefix = 'In Bridge.Hand.prototype._hasCard - '
	Bridge.checkSuit( suit, prefix );
	Bridge.checkRank( rank, prefix );
	
	return this.cards[ suit ][ rank ];
};

/**
 * Generate a html display of this hand.
 * @return {string} HTML representation of this deal.
 */
Bridge.Hand.prototype.toHTML = function() {
	this.html = '';
	this.html += 'Direction : ' + Bridge.directions[ this. direction ].html;
	this.html += ', Name : ' + this.name + ' - ';
	_.each( Bridge.suitOrder, function( suit ) {
		this.html += Bridge.suits[ suit ].html + ' ';
		if ( _.isEmpty( this.cards[ suit ] ) ) {
			this.html += '-';
		}
		else {
			_.each( Bridge.rankOrder, function( rank ) {
				if ( this.cards[ suit ][ rank ] ) {
					this.html += Bridge.ranks[ rank ].html;
				}
			}, this);
		}
		this.html += ' ';
	}, this);
	return this.html;
};

/**
 * Generate a string display of this hand.
 * @return {string} string representation of this deal.
 */
Bridge.Hand.prototype.toString = function() {
	return this.toHTML();
};

